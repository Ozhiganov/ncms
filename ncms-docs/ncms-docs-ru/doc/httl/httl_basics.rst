.. httl_basics:


.. contents::


Основы HTTL
===========

HTTL это язык шаблонов подобный `Apache Velocity <http://velocity.apache.org>`  который
компилируется в быстрый исполняемый байт код.

Пример HTTL кода

.. code-block:: html

    #if(books)
        #for(Book book: books)
            <td>${book.title}</td>
        #end
    #end

По умолчанию в HTTL включены 6 директив: `#set, #if, #else, #for, #break, #macro`


Вывод результата выражений HTTL
-------------------------------

Формат::

    ${expression}

Пример::

    ${User.name}

В данном случае результат выражений преобразуется в html код страницы так, чтобы он не был валидной `html` разметкой. Например
`<b>text</b>` как результат выражения преобразуется в `&lt;b&gt;text&lt;/b&gt;` .
Для того, чтобы отключить это преобразование используется конструкция `$!`::

  $!{Expression}

В этом случае разработчик шаблона должен быть уверен, что результат выражения `$!{Expression}` не вызовет проблем с безопасностью
при отображении страницы.


Комментарии в HTTL
------------------

Строчные комментарии помечаюся как `##` в начале строки::

    ## Это комментарий

Блочные коментарии начинаются с `#*` и заканчиваются `*#`::

    #*
        Это
            блочный комментарий в HTTL
    *#


Escape директивы
----------------

Escape директива #[...]#
************************

Формат::

    #[этот блок не HTTL]#

Пример::

   #[This is no parse block: #if ${name}]#


Escape $ и # символов
*********************

Формат::

    \#
    \$
    \\

Символ ``\`` перед ``#``, ``$``, ``\`` выводит жти символы как есть
исключая из HTTL разметки.


Выражения
---------

.. note::

    Выражения основаны на выражениях языка `Java` поэтому, ниже будут перечислены
    только отличия от правил выражений в `Java`

* Если в цепочке вызовов ``${foo.bar.blabla}`` один из элементов вернет `null`
  то все выражение будет интерпретировано как `null`.
* Оператор `==` соответствует сравнению `java` объектов с помощью `.equals`. Иными словами
  `foo == bar` эквивалентно `foo.equals(bar)`  в `java`
* Выражение в одинарных `'` или двойных кавычках `"` интерпретируется как строка.
  Если есть необходимость использовать одиночный символ (типа `char`) то мы его
  заключаем в обратные кавычки `\`\``
* `+` в выражениях, где первый аргумент число будет интерпретироваться как
   арифметическое сложение. Например: `${1 + "2"}` выведет `3` вместо 12. Для
   конканценации строк используйте пару: `${s1}${s2}`
* Доступ к значениям свойств экземпляров `java` классов осуществляется по имени свойств
  Например: `${user.name}` эквивалентно вызову `${user.getName()}`
* Результат выражения с логическим `OR` является последним ненулевым/непустым элементом выражения.
  Например результатом выражения `${list1 || list2}`  будет `list1`  если `list1` не пуст,
  в противном случае будет `list2`
* Числовые long литералы могут быть заданы как `<number>L` или `<number>l`.
  Например `3L` или `3l`. В случае, если используется `L` результатом будет
  объект класса `java.lang.Long` для маленького `l` результатом будет примитивный `long`
* Для доступа к данным в списках `java.util.List` или в ассоциированных коллекциях
  `java.util.Map` можно использовать оператор квадратные скобки `[]`.  Например,
  выражение `${mylist[0]}` эквивалентно `${mylist.get(0)}`, а `${mymap['foo']}`
  эквивалентно `${mymap.get("foo")}`
* Результатом выражения `${["a", "b", "c"]}` является `java.util.List` содержащий эти элементы.
* Результатом выражения: `${["foo":"bar", "foo2":"bar2"]}` является `java.util.Map` с отношениями
  `foo => bar` и `foo2 => bar2`
* Прямое обращение к статическим методам при помощи префикса `@`::

    ${@java.lang.Math.min(1,2)}
    ${@Math.min(1,2)}


Дополнительно отметим поддержку `instanceof` и `new` операторов::

    ${user instanceof httl.test.model.User}
    ${user instanceof User}
    ${new httl.test.model.User("a","b","c").name}
    ${new User("a","b","c").name}

Установка переменных #set
-------------------------

Формат::

    #set(type name)
    #set(name = expression)
    #set(type name = expression)

Где `name` это имя переменной, `type` java тип переменной


Пример::

    #set(firstName = "John")
    #set(String lastName = "Doe")

В этом примере переменная с именем  `firstName` должны быть определена выше по шаблону::

    #set(String firstName)


Условные выражения #if и #else
------------------------------

Формат::

    #if(expression)
    ...
    #end

Пример::

    #if(user.role == "admin")
        ...
    #else(user.role =="member")
        ... в противном случае если роль равна 'member'
    #else
        ... если ни то и ни другое, тогда выполняется этот блок
    #end

Каждый `#if` должен завершаться `#end` после набора опциональных `#else` директив.


Итерация по коллекциям #for
---------------------------

Формат::

    #for(name: expression)

    #for(type name: expression)

Пример::

    #for(books: books)
        ${for.index}
        ${for.size}
        ${for.first}
        ${for.last}
    #end

В теле блока `for` определен объект `for` со следующими свойствами:

* `for.index` Текущий номер итерации, начиная с ``0``
* `for.size` Размер коллекции по которой происходит итерация
* `for.fist` Первый элемент коллекции
* `for.last` Последний элемент коллекции


Явное определение типа элемента коллекции::

    #for(Book book: booklist)
        ${book.title}
    #end

В данном примере явно определяем тип элемента коллекции, к которому приводится
каждый элемент.

Выполнить девять раз::

    #for(9)

Вывести от одного до девяти::

    #for(i: 1..9)

Вывести ``10,20,30`` где аргумент определен как массив `[]`::

    #for(i: [10, 20, 30])

Взять для итерации первое непустое множество `books1` или `books2`::

    #for (book: books1 || books2)

Итерации по сумме двух множеств::

    #for (book: books1 + books2)

Сортировать коллекцию, затем произвести по ней итерацию::

    #for (book: books.sort)

Рекурсивная итерация, элементы меню имеют метод `getChildren`,
которые возвращают коллекцию подэлементов. Итерация по всем
элементам в данной иерархии::

#for (Menu menu: menus.recursive ("getChildren"))

Прерывание цикла с помощью #break
*********************************

Формат::

    #break
    #break (expression)

В случае если `expression` возвращает `true` или непустая строка
выполнение цикла будет прервано

.. note::

    Делайте условный `#break` прямо в теле директивы::

        #break (i ​​== j) ## правильно

    Это существенно лаконичней и более производительно чем::

        #if (i == j) #break #end

Выполнение действия если коллекция пуста #for #else
***************************************************

Формат::

    #else
    #else(expression)

Пример::

    #for (book: books)
	    ...
    #else
	    ... # выполняется когда коллекция пуста
    #end



Макросы #macro
--------------

.. todo::
    TODO
